// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/inventory-service/internal/repository/mongodb (interfaces: MongoDBCollection,MongoDBDatabase,MongoDBClient)
//
// Generated by this command:
//
//	mockgen -package mock_mongodb -destination mocks/mongodb_mock.go github.com/inventory-service/internal/repository/mongodb MongoDBCollection,MongoDBDatabase,MongoDBClient
//

// Package mock_mongodb is a generated GoMock package.
package mock_mongodb

import (
	context "context"
	reflect "reflect"

	mongodb "github.com/inventory-service/internal/repository/mongodb"
	mongo "go.mongodb.org/mongo-driver/mongo"
	options "go.mongodb.org/mongo-driver/mongo/options"
	readpref "go.mongodb.org/mongo-driver/mongo/readpref"
	gomock "go.uber.org/mock/gomock"
)

// MockMongoDBCollection is a mock of MongoDBCollection interface.
type MockMongoDBCollection struct {
	ctrl     *gomock.Controller
	recorder *MockMongoDBCollectionMockRecorder
	isgomock struct{}
}

// MockMongoDBCollectionMockRecorder is the mock recorder for MockMongoDBCollection.
type MockMongoDBCollectionMockRecorder struct {
	mock *MockMongoDBCollection
}

// NewMockMongoDBCollection creates a new mock instance.
func NewMockMongoDBCollection(ctrl *gomock.Controller) *MockMongoDBCollection {
	mock := &MockMongoDBCollection{ctrl: ctrl}
	mock.recorder = &MockMongoDBCollectionMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockMongoDBCollection) EXPECT() *MockMongoDBCollectionMockRecorder {
	return m.recorder
}

// DeleteOne mocks base method.
func (m *MockMongoDBCollection) DeleteOne(ctx context.Context, filter any, opts ...*options.DeleteOptions) (*mongo.DeleteResult, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, filter}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "DeleteOne", varargs...)
	ret0, _ := ret[0].(*mongo.DeleteResult)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// DeleteOne indicates an expected call of DeleteOne.
func (mr *MockMongoDBCollectionMockRecorder) DeleteOne(ctx, filter any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, filter}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteOne", reflect.TypeOf((*MockMongoDBCollection)(nil).DeleteOne), varargs...)
}

// Find mocks base method.
func (m *MockMongoDBCollection) Find(ctx context.Context, filter any, opts ...*options.FindOptions) (*mongo.Cursor, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, filter}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Find", varargs...)
	ret0, _ := ret[0].(*mongo.Cursor)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Find indicates an expected call of Find.
func (mr *MockMongoDBCollectionMockRecorder) Find(ctx, filter any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, filter}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Find", reflect.TypeOf((*MockMongoDBCollection)(nil).Find), varargs...)
}

// FindOne mocks base method.
func (m *MockMongoDBCollection) FindOne(ctx context.Context, filter any, opts ...*options.FindOneOptions) *mongo.SingleResult {
	m.ctrl.T.Helper()
	varargs := []any{ctx, filter}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "FindOne", varargs...)
	ret0, _ := ret[0].(*mongo.SingleResult)
	return ret0
}

// FindOne indicates an expected call of FindOne.
func (mr *MockMongoDBCollectionMockRecorder) FindOne(ctx, filter any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, filter}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindOne", reflect.TypeOf((*MockMongoDBCollection)(nil).FindOne), varargs...)
}

// InsertOne mocks base method.
func (m *MockMongoDBCollection) InsertOne(ctx context.Context, document any, opts ...*options.InsertOneOptions) (*mongo.InsertOneResult, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, document}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "InsertOne", varargs...)
	ret0, _ := ret[0].(*mongo.InsertOneResult)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// InsertOne indicates an expected call of InsertOne.
func (mr *MockMongoDBCollectionMockRecorder) InsertOne(ctx, document any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, document}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "InsertOne", reflect.TypeOf((*MockMongoDBCollection)(nil).InsertOne), varargs...)
}

// UpdateOne mocks base method.
func (m *MockMongoDBCollection) UpdateOne(ctx context.Context, filter, update any, opts ...*options.UpdateOptions) (*mongo.UpdateResult, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, filter, update}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "UpdateOne", varargs...)
	ret0, _ := ret[0].(*mongo.UpdateResult)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// UpdateOne indicates an expected call of UpdateOne.
func (mr *MockMongoDBCollectionMockRecorder) UpdateOne(ctx, filter, update any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, filter, update}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateOne", reflect.TypeOf((*MockMongoDBCollection)(nil).UpdateOne), varargs...)
}

// MockMongoDBDatabase is a mock of MongoDBDatabase interface.
type MockMongoDBDatabase struct {
	ctrl     *gomock.Controller
	recorder *MockMongoDBDatabaseMockRecorder
	isgomock struct{}
}

// MockMongoDBDatabaseMockRecorder is the mock recorder for MockMongoDBDatabase.
type MockMongoDBDatabaseMockRecorder struct {
	mock *MockMongoDBDatabase
}

// NewMockMongoDBDatabase creates a new mock instance.
func NewMockMongoDBDatabase(ctrl *gomock.Controller) *MockMongoDBDatabase {
	mock := &MockMongoDBDatabase{ctrl: ctrl}
	mock.recorder = &MockMongoDBDatabaseMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockMongoDBDatabase) EXPECT() *MockMongoDBDatabaseMockRecorder {
	return m.recorder
}

// Collection mocks base method.
func (m *MockMongoDBDatabase) Collection(collectionName string, opts ...*options.CollectionOptions) mongodb.MongoDBCollection {
	m.ctrl.T.Helper()
	varargs := []any{collectionName}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Collection", varargs...)
	ret0, _ := ret[0].(mongodb.MongoDBCollection)
	return ret0
}

// Collection indicates an expected call of Collection.
func (mr *MockMongoDBDatabaseMockRecorder) Collection(collectionName any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{collectionName}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Collection", reflect.TypeOf((*MockMongoDBDatabase)(nil).Collection), varargs...)
}

// MockMongoDBClient is a mock of MongoDBClient interface.
type MockMongoDBClient struct {
	ctrl     *gomock.Controller
	recorder *MockMongoDBClientMockRecorder
	isgomock struct{}
}

// MockMongoDBClientMockRecorder is the mock recorder for MockMongoDBClient.
type MockMongoDBClientMockRecorder struct {
	mock *MockMongoDBClient
}

// NewMockMongoDBClient creates a new mock instance.
func NewMockMongoDBClient(ctrl *gomock.Controller) *MockMongoDBClient {
	mock := &MockMongoDBClient{ctrl: ctrl}
	mock.recorder = &MockMongoDBClientMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockMongoDBClient) EXPECT() *MockMongoDBClientMockRecorder {
	return m.recorder
}

// Connect mocks base method.
func (m *MockMongoDBClient) Connect(ctx context.Context) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Connect", ctx)
	ret0, _ := ret[0].(error)
	return ret0
}

// Connect indicates an expected call of Connect.
func (mr *MockMongoDBClientMockRecorder) Connect(ctx any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Connect", reflect.TypeOf((*MockMongoDBClient)(nil).Connect), ctx)
}

// Database mocks base method.
func (m *MockMongoDBClient) Database(name string, opts ...*options.DatabaseOptions) mongodb.MongoDBDatabase {
	m.ctrl.T.Helper()
	varargs := []any{name}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Database", varargs...)
	ret0, _ := ret[0].(mongodb.MongoDBDatabase)
	return ret0
}

// Database indicates an expected call of Database.
func (mr *MockMongoDBClientMockRecorder) Database(name any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{name}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Database", reflect.TypeOf((*MockMongoDBClient)(nil).Database), varargs...)
}

// Disconnect mocks base method.
func (m *MockMongoDBClient) Disconnect(ctx context.Context) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Disconnect", ctx)
	ret0, _ := ret[0].(error)
	return ret0
}

// Disconnect indicates an expected call of Disconnect.
func (mr *MockMongoDBClientMockRecorder) Disconnect(ctx any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Disconnect", reflect.TypeOf((*MockMongoDBClient)(nil).Disconnect), ctx)
}

// Ping mocks base method.
func (m *MockMongoDBClient) Ping(ctx context.Context, readPref *readpref.ReadPref) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Ping", ctx, readPref)
	ret0, _ := ret[0].(error)
	return ret0
}

// Ping indicates an expected call of Ping.
func (mr *MockMongoDBClientMockRecorder) Ping(ctx, readPref any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Ping", reflect.TypeOf((*MockMongoDBClient)(nil).Ping), ctx, readPref)
}
